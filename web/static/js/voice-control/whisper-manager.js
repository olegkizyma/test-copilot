/**
 * –ú–µ–Ω–µ–¥–∂–µ—Ä Whisper —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—ó –¥–ª—è –≤–∏—Å–æ–∫–æ—è–∫—ñ—Å–Ω–æ–≥–æ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –º–æ–≤–∏
 * –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î –ª–æ–∫–∞–ª—å–Ω–∏–π Whisper —Å–µ—Ä–≤—ñ—Å –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü—ñ—ó
 */

import { logger } from '../core/logger.js';

export class WhisperManager {
    constructor() {
        this.logger = new logger.constructor('WHISPER');
        this.serviceUrl = 'http://localhost:3002';
        this.isServiceAvailable = false;
        this.mediaRecorder = null;
        this.audioChunks = [];
        this.isRecording = false;
    this._recorderState = 'inactive'; // mirror for safety
    this._initInProgress = false;
        
        this.logger.info('Whisper Manager initialized');
    }

    /**
     * –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ Whisper —Å–µ—Ä–≤—ñ—Å—É
     */
    async checkServiceAvailability() {
        try {
            const response = await fetch(`${this.serviceUrl}/health`);
            if (response.ok) {
                const data = await response.json();
                this.isServiceAvailable = true;
                this.logger.info(`‚úÖ Whisper service available: ${data.model} on ${data.device}`);
                return true;
            }
        } catch (error) {
            this.logger.warn(`‚ö†Ô∏è Whisper service not available: ${error.message}`);
            this.isServiceAvailable = false;
        }
        return false;
    }

    /**
     * –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –º–µ–¥—ñ–∞-–∑–∞–ø–∏—Å—É
     */
    async initializeRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    sampleRate: 16000,
                    channelCount: 1,
                    echoCancellation: true,
                    noiseSuppression: true
                } 
            });

            this.mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'audio/webm;codecs=opus'
            });

            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.audioChunks.push(event.data);
                }
            };

            this.mediaRecorder.onstop = () => {
                this._recorderState = 'inactive';
                this.isRecording = false;
                this.logger.info('üé§ Recording stopped');
            };

            this.mediaRecorder.onstart = () => {
                this._recorderState = 'recording';
            };

            this.logger.info('üé§ Media recording initialized');
            return true;

        } catch (error) {
            this.logger.error('‚ùå Failed to initialize recording:', error);
            return false;
        }
    }

    async ensureMediaRecorderReady() {
        if (this.mediaRecorder && this.mediaRecorder.state === 'inactive') {
            return true;
        }
        if (!this.mediaRecorder) {
            if (this._initInProgress) {
                // wait a bit for parallel init
                await new Promise(res => setTimeout(res, 50));
                if (this.mediaRecorder) return true;
            }
            this._initInProgress = true;
            try {
                return await this.initializeRecording();
            } finally {
                this._initInProgress = false;
            }
        }
        // If state is 'recording' unexpectedly, attempt to stop and recreate
        if (this.mediaRecorder?.state === 'recording') {
            try { this.mediaRecorder.stop(); } catch (_) {}
            await new Promise(res => setTimeout(res, 50));
            try { this.cleanup(); } catch (_) {}
            return await this.initializeRecording();
        }
        return true;
    }

    /**
     * –ü–æ—á–∞—Ç–æ–∫ –∑–∞–ø–∏—Å—É –∞—É–¥—ñ–æ
     */
    async startRecording() {
        if (this.isRecording || this.mediaRecorder?.state === 'recording') {
            this.logger.warn('Recording already in progress');
            return false;
        }

        if (!this.mediaRecorder) {
            await this.initializeRecording();
        }

        if (!this.mediaRecorder) {
            this.logger.error('MediaRecorder not available');
            return false;
        }

        try {
            this.audioChunks = [];
            // –Ü–Ω–∫–æ–ª–∏ –±—Ä–∞—É–∑–µ—Ä –∫–∏–¥–∞—î NotSupportedError/InvalidStateError ‚Äî –ø—Ä–æ–±—É—î–º–æ —Ä–µ-—ñ–Ω—ñ—Ç/–ø–æ–≤—Ç–æ—Ä
            try {
                this.mediaRecorder.start();
            } catch (err) {
                this.logger.warn('mediaRecorder.start() failed, attempting recovery:', err?.name || err);
                // Recovery path
                try { this.cleanup(); } catch (_) {}
                const ok = await this.initializeRecording();
                if (!ok) throw err;
                this.mediaRecorder.start();
            }
            this.isRecording = true;
            this._recorderState = 'recording';
            this.logger.info('üé§ Recording started');
            return true;
        } catch (error) {
            this.logger.error('‚ùå Failed to start recording:', error);
            return false;
        }
    }

    /**
     * –ó—É–ø–∏–Ω–∫–∞ –∑–∞–ø–∏—Å—É —Ç–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –∞—É–¥—ñ–æ
     */
    async stopRecording() {
        if (!this.mediaRecorder) {
            this.logger.warn('No MediaRecorder to stop');
            return null;
        }

        // –Ø–∫—â–æ –≤–∂–µ –Ω–µ –ø–∏—à–µ–º–æ ‚Äî –≤—Å–µ –æ–¥–Ω–æ —Å–ø—Ä–æ–±—É—î–º–æ —Å—Ñ–æ—Ä–º—É–≤–∞—Ç–∏ blob
        if (!this.isRecording && this.mediaRecorder.state !== 'recording') {
            if (this.audioChunks.length === 0) {
                this.logger.warn('No audio data recorded');
                return null;
            }
            const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
            this.logger.info(`üé§ Returning last audio buffer, size: ${audioBlob.size} bytes`);
            return audioBlob;
        }

        return new Promise((resolve) => {
            const finalize = () => {
                this.isRecording = false;
                this._recorderState = 'inactive';
                if (this.audioChunks.length === 0) {
                    this.logger.warn('No audio data recorded');
                    resolve(null);
                    return;
                }
                const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                this.logger.info(`üé§ Recording stopped, audio size: ${audioBlob.size} bytes`);
                resolve(audioBlob);
            };

            try {
                // restore default onstop, then add a once handler
                this.mediaRecorder.onstop = finalize;
                if (this.mediaRecorder.state === 'recording') {
                    this.mediaRecorder.stop();
                } else {
                    // already inactive
                    finalize();
                }
            } catch (e) {
                this.logger.warn('Error on mediaRecorder.stop(), forcing finalize:', e);
                finalize();
            }
        });
    }

    /**
     * –¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü—ñ—è –∞—É–¥—ñ–æ —á–µ—Ä–µ–∑ Whisper —Å–µ—Ä–≤—ñ—Å
     */
    async transcribeAudio(audioBlob, language = 'uk', options = {}) {
        if (!this.isServiceAvailable) {
            await this.checkServiceAvailability();
            if (!this.isServiceAvailable) {
                throw new Error('Whisper service not available');
            }
        }

        try {
            const { useVAD = true } = options;
            this.logger.info(`ü§ñ Transcribing audio (${audioBlob.size} bytes) with language: ${language}, use_vad: ${useVAD}`);
            
            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.webm');
            formData.append('language', language);
            formData.append('use_vad', useVAD ? 'true' : 'false');  // –í–º–∏–∫–∞—î–º–æ VAD –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º

            const response = await fetch(`${this.serviceUrl}/transcribe`, {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error(`Transcription failed: ${response.status} ${response.statusText}`);
            }

            const result = await response.json();
            
            if (result.status === 'success') {
                this.logger.info(`‚úÖ Transcription successful: "${result.text}"`);
                return {
                    text: result.text,
                    language: result.language,
                    transcriptionTime: result.transcription_time,
                    confidence: 1.0 // Whisper –Ω–µ –ø–æ–≤–µ—Ä—Ç–∞—î confidence, –∞–ª–µ —è–∫—ñ—Å—Ç—å –≤–∏—Å–æ–∫–∞
                };
            } else if (result.status === 'filtered') {
                this.logger.info(`üö´ Transcription filtered: "${result.original_text}" - ${result.reason}`);
                return {
                    text: '', // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –ø–æ—Ä–æ–∂–Ω—ñ–π —Ç–µ–∫—Å—Ç –¥–ª—è –≤—ñ–¥—Ñ—ñ–ª—å—Ç—Ä–æ–≤–∞–Ω–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
                    language: result.language || language,
                    transcriptionTime: result.transcription_time,
                    confidence: 0.0,
                    filtered: true,
                    reason: result.reason,
                    originalText: result.original_text
                };
            } else {
                throw new Error(result.error || 'Transcription failed');
            }

        } catch (error) {
            this.logger.error('‚ùå Transcription error:', error);
            throw error;
        }
    }

    /**
     * –ü–æ–≤–Ω–∏–π —Ü–∏–∫–ª: –∑–∞–ø–∏—Å -> –∑—É–ø–∏–Ω–∫–∞ -> —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü—ñ—è
     */
    async recordAndTranscribe(language = 'uk') {
        try {
            // –ü–æ—á–∏–Ω–∞—î–º–æ –∑–∞–ø–∏—Å
            const started = await this.startRecording();
            if (!started) {
                throw new Error('Failed to start recording');
            }

            // –ß–µ–∫–∞—î–º–æ –ø–æ–∫–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –∑–∞–≤–µ—Ä—à–∏—Ç—å (—Ü–µ –º–∞—î –∫–æ–Ω—Ç—Ä–æ–ª—é–≤–∞—Ç–∏—Å—è –∑–∑–æ–≤–Ω—ñ)
            // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ —Ñ—É–Ω–∫—Ü—ñ—é –¥–ª—è –∑—É–ø–∏–Ω–∫–∏ —Ç–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü—ñ—ó
            return {
                stop: async () => {
                    const audioBlob = await this.stopRecording();
                    if (!audioBlob) {
                        throw new Error('No audio recorded');
                    }
                    return await this.transcribeAudio(audioBlob, language, { useVAD: true });
                }
            };

        } catch (error) {
            this.logger.error('‚ùå Record and transcribe error:', error);
            throw error;
        }
    }

    /**
     * –®–≤–∏–¥–∫–∏–π –∑–∞–ø–∏—Å –∑ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ—é –∑—É–ø–∏–Ω–∫–æ—é –ø—ñ—Å–ª—è —Ç–∏—à—ñ
     */
    async quickRecord(maxDuration = 10000, language = 'uk') {
        try {
            const started = await this.startRecording();
            if (!started) {
                throw new Error('Failed to start recording');
            }

            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∞ –∑—É–ø–∏–Ω–∫–∞ —á–µ—Ä–µ–∑ maxDuration –º—ñ–ª—ñ—Å–µ–∫—É–Ω–¥
            setTimeout(async () => {
                if (this.isRecording) {
                    this.logger.info(`‚è∞ Auto-stopping recording after ${maxDuration}ms`);
                    await this.stopRecording();
                }
            }, maxDuration);

            // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ Promise, —è–∫–∏–π —Ä–µ–∑–æ–ª–≤–∏—Ç—å—Å—è –∫–æ–ª–∏ –∑–∞–ø–∏—Å –∑—É–ø–∏–Ω–∏—Ç—å—Å—è
            return new Promise(async (resolve, reject) => {
                const checkRecording = async () => {
                    if (!this.isRecording) {
                        try {
                            // –û—Ç—Ä–∏–º—É—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π blob
                            const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                            if (audioBlob.size > 0) {
                                const result = await this.transcribeAudio(audioBlob, language);
                                resolve(result);
                            } else {
                                reject(new Error('No audio recorded'));
                            }
                        } catch (error) {
                            reject(error);
                        }
                    } else {
                        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∑–Ω–æ–≤—É —á–µ—Ä–µ–∑ 100–º—Å
                        setTimeout(checkRecording, 100);
                    }
                };
                
                setTimeout(checkRecording, 100);
            });

        } catch (error) {
            this.logger.error('‚ùå Quick record error:', error);
            throw error;
        }
    }

    /**
     * –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Å–ø–∏—Å–∫—É –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –º–æ–¥–µ–ª–µ–π
     */
    async getAvailableModels() {
        try {
            const response = await fetch(`${this.serviceUrl}/models`);
            if (response.ok) {
                return await response.json();
            }
            throw new Error(`Failed to get models: ${response.status}`);
        } catch (error) {
            this.logger.error('‚ùå Failed to get models:', error);
            throw error;
        }
    }

    /**
     * –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Å—Ç–∞–Ω—É –∑–∞–ø–∏—Å—É
     */
    getRecordingState() {
        return {
            isRecording: this.isRecording,
            isServiceAvailable: this.isServiceAvailable,
            serviceUrl: this.serviceUrl
        };
    }

    /**
     * –û—á–∏—â–µ–Ω–Ω—è —Ä–µ—Å—É—Ä—Å—ñ–≤
     */
    cleanup() {
        if (this.mediaRecorder && this.mediaRecorder.stream) {
            this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
        }
        this.mediaRecorder = null;
        this.audioChunks = [];
        this.isRecording = false;
        this.logger.info('üßπ Whisper manager cleanup completed');
    }
}